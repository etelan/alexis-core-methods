Binary Tree Inorder

// Recursive

private void dfs(TreeNode node, List<Integer> ret) {
    if (node != null) {
        dfs(node.left, ret);
        ret.add(node.val);
        dfs(node.right, ret);
    }
}


// Iterative

public List<Integer> inorderTraversal(TreeNode root) {
   Stack<TreeNode> stack = new Stack<>();
   List<Integer> ret = new ArrayList<>();
   while (true) {
       while (root != null) {
           stack.push(root);
           root = root.left;
       }
       if (stack.isEmpty()) {
           break;  // no node left
       }
       TreeNode node = stack.pop();
       ret.add(node.val);
       root = node.right;
   }
   return ret;
}